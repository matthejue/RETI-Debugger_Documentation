\documentclass{report}

\input{./content/packages}
\input{./content/declarations}
\input{./content/desgin}

\begin{document}

\fontsize{10pt}{12pt}\selectfont

\newgeometry{margin=4cm, bottom=5cm, headheight=0.5cm}

\input{./content/titlepage}

\tableofcontents
\thispagestyle{empty}
\clearpage
\pagestyle{plain}
\pagenumbering{Roman}

\listoffigures
\newpage
\listoftables

\clearpage
\fancypagestyle{plain}{%
	\fancyhf{}
	\fancyfootoffset{0.5cm}
	\fancyheadoffset{0.5cm}
  \fancyhead[L]{\color{PrimaryColor}\leftmark}
	\fancyhead[R]{\color{PrimaryColor}\rightmark}
	\renewcommand{\headrulewidth}{0.4mm}
  \renewcommand{\headrule}{\hbox to\headwidth{\color{PrimaryColor}\leaders\hrule height \headrulewidth\hfill}}
	\fancyfoot[C]{\thepage}
}
\pagenumbering{arabic}
\pagestyle{default}

\chapter{Motivation}
% mit dem Gedanken, dass Studenten das benutzen, daher Keybindings im Appendix sehr intuitiv

When I had to implement a PicoC-to-RETI-Compiler for my bachelor thesis I often had the problem that I had to debug the RETI code produced by the \alert{PicoC-Compiler}. \alert{PicoC} is a subset of C used in the operating systems lecture at the university of freiburg and \alert{RETI} is an assembler used in the operating systems and technical computer science lectures at the univeristy of freiburg. The PicoC-Compiler I implemented for the lecture has actually also a built-in \alert{RETI-Interpreter} that was neccessary to test the RETI-Code produced by the PicoC-Compiler. But just executing the RETI-Code and putting in print-Statements was not sufficient, I needed some kind of debugger. I came up with a provisional solution that can e.g. be seen \href{https://asciinema.org/a/526542}{here}. I implemented a sort of Vim plugin that was actually just a \href{https://github.com/matthejue/PicoC-Compiler/blob/master/src/interpr_showcase.vim}{config file} with special keybindings and settings. I implemented a special so called \alert{Show-Mode} into the PicoC-Compiler which actually just wrote the state of the RETI processor after each instruction with all it's registers, EPROM, UART and SRAM into a file and the provisional Vim plugin just jumped to the right place in this big file and used several windows that scrolled synchronously to fit as much RETI instructions as possible into the terminal window.

This solution was very proviosonal and it was the best low effort solution I could come up with in the short amount of time I had. The solution surely had it's flaws, because the whole program (codesegment) and datasegment hat to fit into the visible windows and one had to guess the number of windows neccessary beforehand. And if the program is too big there is a limit how for one can decrease the font size of the terminal window in order to fit as much RETI instructions as possible into the terminal window.

When I tutored the Operating Systems lecture using this \alert{Show-Mode} of the RETI-Interpreter to present the solutions of RETI exercises to the students I felt the urge to have a better tool for this, because for some programs I had to reduce the font size of the terminal window a lot such that the students could just barely see the instructions and values of the registers and memory cells.

And now for this missing semester course the choice for my project came quite naturally, I wanted to finally implement a proper \alert{RETI-Debugger} that communicates with the RETI-Interpreter to show the state of the RETI processor after each instruction with the not yet implemented possibility to change values in the RETI processor while it's executing the RETI program and doing other shenanigans like compiling the PicoC code within the buffer directly into RETI code etc.

In the following chapter \ref{chap:choosen_topics} two topics from the lecture that were used in the development of the plugin are going to be explained in more detail.

\chapter{Choosen Topics}
\label{chap:choosen_topics}

By the choice of my project the two main topics I had to choose were \alert{Neovim} and \alert{Python}, as the RETI-Debugger is going to be implemented as a \alert{Neovim plugin} and the RETI-Interpreter that is part of the PicoC-Compiler is implemented in Python. These two topics and other topics from the lecture also touched in the project are described in table \ref{tab:topics}.

\begin{table}[H]
	\centering
	\begin{tblr}{
		width = \linewidth,
		colspec = {Q[1]Q[3]},
		column{1} = {PrimaryColorDimmed, c},
		column{2} = {BoxColor, l},
		row{1} = {PrimaryColor, fg=white},
		hlines = {PrimaryColor},
		vlines = {PrimaryColor},
		}
		Topics                 & Description                                                                                                                                                                                                                                                                                          \\
		Texteditor: Vim/Neovim & {\labelitemi\hspace{\dimexpr\labelsep+0.5\tabcolsep}Creating a Neovim plugin that communicates with the RETI-Interpreter and PicoC-Compiler following a protocol to inter alia show the state of the RETI processor after each instruction and compile the PicoC code within the buffer to RETI code \\\labelitemi\hspace{\dimexpr\labelsep+0.5\tabcolsep}As fully featured IDE with language server and autoformater for lua and python by using lazy.nvim} \\
		Automation: Python     & {\labelitemi\hspace{\dimexpr\labelsep+0.5\tabcolsep}Language used in the RETI-Interpreter and PicoC-Compiler which was extended to act like a deamon that communicates with the RETI-Debugger Neovim plugin. Furthermore:                                                                            \\\hspace*{0.5\leftmargin}\labelitemii\hspace{\dimexpr\labelsep+0.5\tabcolsep}Reading metadatafrom comments was added\\\hspace*{0.5\leftmargin}\labelitemii\hspace{\dimexpr\labelsep+0.5\tabcolsep}The code quality was improved by restructering parts of the code\\\hspace*{0.5\leftmargin}\labelitemii\hspace{\dimexpr\labelsep+0.5\tabcolsep}Several bugs have been fixed}                                                                                                                                                                                                                \\
    Docker                 & {\labelitemi\hspace{\dimexpr\labelsep+0.5\tabcolsep} To provide a way for the students who are going to test this plugin to quickly set up and run the plugin with the provided \href{https://github.com/matthejue/RETI-Debugger/blob/main/Dockerfile}{Dockerfile}\\\labelitemi\hspace{\dimexpr\labelsep+0.5\tabcolsep} The PDF of this report was autogenerated with the help of Github Actions with \href{https://github.com/matthejue/RETI-Debugger_Documentation/blob/master/.github/workflows/create_and_upload_pdf.yml}{this} script which is syntactically in many ways similar to Docker Compose}                                                                                                                                       \\
		% \\\labelitemi\hspace{\dimexpr\labelsep+0.5\tabcolsep} As a way to know whether the plugin also works apart of my own working environment
		% \\\labelitemi\hspace{\dimexpr\labelsep+0.5\tabcolsep} As a way to document the installation of the plugin}                                                                                                                                                                                                                                                \\
		% Linux                  & {\labelitemi\hspace{\dimexpr\labelsep+0.5\tabcolsep}I was running NixOS, a quite special linux distribution for developing the plugin, which, by it's high configurability enabled a fast workflow that wouldn't be possible in other non-linux operating systems}                                   \\
		% Git and Github         & {\labelitemi\hspace{\dimexpr\labelsep+0.5\tabcolsep}Used as version control system for the development of the RETI-Debugger Neovim Plugin and PicoC-Compiler and RETI-Interpreter                                                                                                                    \\\labelitemi\hspace{\dimexpr\labelsep+0.5\tabcolsep}Github was used as place from which both the PicoC-Compiler and RETI-Interpreter executable and also the RETI-Debuger Neovim plugin get downloaded using lazy.nvim} \\
		Latex                  & {\labelitemi\hspace{\dimexpr\labelsep+0.5\tabcolsep}Used for writing this report and thus also the documentation for the RETI-Debugger Neovim plugin in the appendix of this report                                                                                                                  \\\labelitemi\hspace{\dimexpr\labelsep+0.5\tabcolsep}Used for writing a template used in this report that is also going to be used in my master thesis}\\
		% LLM's                  & {\labelitemi\hspace{\dimexpr\labelsep+0.5\tabcolsep}I used \url{https://www.perplexity.ai/} a lot to quickly get answers to some questions about lua, python, latex and certain \inlinebox{vim.loop} (i.e. libuv), \inlinebox{vim.api} functions} and vim settings                                   \\
	\end{tblr}
	\caption{Topics covered in the project}
	\label{tab:topics}
\end{table}

In the following section \ref{sec:reti-interpreter} the extensions to the RETI-Interpreter that were neccessary to implement a communcation protocol between the RETI-Interpreter and the RETI-Debugger Neovim Plugin and other new features and bug fixes are going to be explained.

\section{RETI-Interpreter}
\label{sec:reti-interpreter}

\subsection{Directory structure}

\subsection{Communication Protocol}
% new commandline options
% communication over stdin and stdout, input and print

\begin{figure}[H]
	\centering
	\resizebox{0.8\textwidth}{!}{
		\tikzfig{communication_protocol}
	}
	\caption{Communication protocol between RETI-Debugger Neovim plugin and RETI-Interpreter}
\end{figure}

\begin{figure}[H]
	\centering
	\resizebox{0.8\textwidth}{!}{
		\tikzfig{communication_protocol_picoc}
	}
	\caption{Communication protocol between RETI-Debugger Neovim plugin and PicoC-Compiler}
\end{figure}

\subsection{Reading in metadata from comments}
% new commandline options

\subsection{Various bugfixes and code improvements}

\section{RETI-Debugger}

\subsection{Directory structure}
% neovim directory structure and lua

\subsection{User Intrerface with Nui}
% menu, input, output popup
% bild mit user interface beschrifftet

\subsection{Asynchronous execution with Libuv}
% communication protocol

\chapter{Preventing unexpected behavior}

\begin{figure}[H]
	\centering
	\resizebox{\textwidth}{!}{
		\tikzfig{statemachine}
	}
	\caption{Statemachine of the different states importartant for access rights of windows}
\end{figure}

\begin{figure}[H]
	\centering
	\resizebox{0.6\textwidth}{!}{
		\tikzfig{statemachine_focus}
	}
	\caption{Small statemachine for making memory focus only at the start}
\end{figure}

\clearpage
\chapter{Appendix}
\pagenumbering{Alph}

\section{Installation and Testing}
% Recommended to just check out \inlinebox{Dockerfile}

For the students who have to test this plugin I recommend to just use the \inlinebox{Dockerfile} in the main folder of the repository as described in \ref{sec:running in a docker image}. The \inlinebox{Dockerfile} just sets everything up for you and you don't have to install anything yourself etc.

If you want to install the plugin directly on your own machine you can follow the instructions in \ref{sec:manual installation}.

\subsection{Running in a Docker Container}
\label{sec:running in a docker image}

If one wants to test the plugin in a clean sandbox without disturbances of any kind the recommended way of testing this plugin is to use the provided \inlinebox{Dockerfile} in the main folder of the repository. Therefore one can execute the following commands in the main folder of the repository to build an \alert{image} and run the image as a \alert{container}:

\begin{terminal}
  |\prompt|git clone https://github.com/matthejue/RETI-Debugger --depth 1
  |\prompt|cd RETI-Debugger
  |\prompt|sudo docker build . -t reti_debugger_test_environment
  |\prompt|sudo docker run -it --rm reti_debugger_test_environment /bin/bash
\end{terminal}

Then in the Docker container if one runs:

\begin{terminal}
	|\prompt|nvim
\end{terminal}

the plugin will install automatically once Neovim starts. In the \inlinebox{Dockerfile} it was specified that the \inlinebox{custom\_init.lua} in the main folder of the repository is going to be used as the configuration file \inlinebox{\sim/.config/nvim/init.lua} for Neovim. And in there it was specified that the \alert{plugin manager} \inlinebox{lazy.nvim} and the RETI-Debugger Neovim plugin are going to be installed automatically when Neovim is going to be started.

Alongside the RETI-Debuggerr Neovim plugin the PicoC-Compiler which includes the \alert{RETI-Interpreter} is also going to be installed automatically. Besides that the \inlinebox{which-key} plugin and the colorscheme \inlinebox{kanagawa} are going to be installed as specified in the \inlinebox{Dockerfile}.

The \inlinebox{kanagawa} plugin is only supposed to make everything look pretier, because else all \alert{Nui} windows are looking really inappropriate. For the \inlinebox{kanagawa} plugin to look as expected the option \inlinebox{vim.opt.termguicolors} is set to \inlinebox{true} in the configuration file.

The \inlinebox{which-key} plugin helps the user with the keybindings by displaying all available keybindings if the \alert{leaderkey} is typed. By the configuration file \inlinebox{custom\_init.lua} the leaderkey is mapped to \inlinebox{Space} and displays all available keybindings where \inlinebox{Space} is the first key that has to be typed. To see all other keybindings one first types the leaderkey \inlinebox{Space} and then \inlinebox{$\leftarrow$}.

After testing one can get rid of the image again by just running:

\begin{terminal}
	|\prompt|sudo docker image rm reti_debugger_test_environment
\end{terminal}

And when running

\begin{terminal}
	|\prompt|sudo docker image ls
\end{terminal}

the image is gone.

\subsection{Manual Installation}
\label{sec:manual installation}

First of all we have to make sure some packages are installed, like Neovim itself, because the RETI-Debugger is a Neovim plugin. The following steps differ depending on the packager manager and also depending on the distribution, because some distributions package repositories also have different names for the packages. The following steps are for the very commonly used package manager \inlinebox{pacman} which is used in Arch based distributions:

% \begin{noindent}
\begin{terminal}
  |\prompt| sudo pacman -Syu 
    && sudo pacman -S git neovim sudo python python-pip make
\end{terminal}
% \end{noindent}

Now we're going to install the RETI-Intepreter. The REIT-Interpreter is part of the PicoC-Compiler. After cloning the repo the recommended way is to install all required packages within a \alert{virtual environment}. Depending on the used \alert{shell} a different file has to be sourced to activate the virtual environment. The overall required steps are depicted in the following:

% \begin{noindent}
\begin{terminal}
|\prompt| git clone https://github.com/matthejue/PicoC-Compiler
   -b missing_semester_project --depth 1
|\prompt| cd PicoC-Compiler
|\prompt| python -m venv .virtualenv
|\prompt| source .virtualenv/bin/activate
|\textcolor{gray}{# or source .virtualenv/bin/activate.fish for fish shell}|
|\prompt| pip install --upgrade pip && pip install -r requirements.txt
\end{terminal}
% \end{noindent}

The following installation steps for the RETI-Interpreter only work for Linux operating systems which adhere to \alert{Filesystem Hierarchy Standard} (FHS). But in general one just has to somehow make \inlinebox{main.py} accessable via the \inlinebox{PATH} environment variable of the respective system or a similar concept, however it might be implemented on the respective system. On systems adhering to FHS the executable can be made accessable by executing:

% \begin{noindent}
\begin{terminal}
  |\prompt| sudo make install
\end{terminal}
% \end{noindent}

After making the RETI-Interpreter directly accessable, now only the RETI-Debugger plugin is left to be installed via the following steps:

% \begin{noindent}
\begin{terminal}
  |\prompt| mv ~/.config/nvim/init.lua{,.bak}
  |\prompt| echo -n 'local lazypath = vim.fn.stdpath("data") .. "/lazy/lazy.nvim"
  if not vim.loop.fs_stat(lazypath) then
    vim.fn.system({
      "git",
      "clone",
      "--filter=blob:none",
      "https://github.com/folke/lazy.nvim.git",
      "--branch=stable", -- latest stable release
      lazypath,
    })
  end
  vim.g.mapleader = " "
  vim.opt.rtp:prepend(lazypath)
  local plugins = {
    {
      "matthejue/RETI-Debugger",
      dependencies = { "MunifTanjim/nui.nvim" },
      opts = {
          keys = {
            load_example = "<leader>rl",
            compile = "<leader>rc",
            start = "<leader>rs",
            hide = "<leader>rh"
          }
      }
    }
  }
  require("lazy").setup(plugins)' > ~/.config/nvim/init.lua
\end{terminal}
% \end{noindent}

As soon as one runs:

% \begin{noindent}
\begin{terminal}
  |\prompt| nvim
\end{terminal}
% \end{noindent}

the plugin will install automatically, because the configuration pasted into \inlinebox{init.lua} is an autoinstall script. This autoinstall script is going to install the \inlinebox{lazy.nvim} \alert{plugin manager} which in turn is going to install the RETI-Debugger Neovim plugin alongside with it's dependencies because of the options passed to \inlinebox{lazy.nvim} that included the installation options for the RETI-Debugger Neovim plugin.

After the RETI-Debugger Neovim plugin and the PicoC-Compiler including the RETI-Interpreter are installed and Neovim is started, the different features of the plugin can be used with the help of the keybindings and commands described in the next section \ref{sec:keybindings and commands}.

\section{Keybindings and Commands}
\label{sec:keybindings and commands}

As soon as Neovim starts, if the configurations from the config file \inlinebox{custom\_init.lua} in the main folder of the RETI-Debugger repo is used in \inlinebox{\sim/.config/init.lua} then all of the commands in \ref{tab:commands} are going to be available by the call to the \inlinebox{setup} function as configured in the config file. The configuration in \inlinebox{custom\_init.lua} is also used by the \inlinebox{Dockerfile} that automatically sets up an image with the plugin to be directly installed and usable as soon as Neovim is started.

% internet connection

\newcommand{\loadretiexample}{Open a menu with a listing of example programs and open one with \inlinebox{Enter}}
\newcommand{\compilepicocbuffer}{Compile PicoC code in buffer to RETI}
\newcommand{\startretibuffer}{Start RETI code in the current buffer in the RETI-Debugger. Mounts the window layout, starts the RETI-Interpreter asynchronously and sets buffer and not yet set global keybindings keybindings}

\begin{table}[H]
	\centering
	\begin{tblr}{
		width = \linewidth,
		colspec = {Q[1]Q[2]},
		row{1} = {PrimaryColor,fg=white},
		column{1} = {l},
		row{even} = {PrimaryColorDimmed},
		hlines = {PrimaryColor},
		vlines = {PrimaryColor},
		}
		Key                              & Effect                                            \\
		\inlinebox{:LoadRETIExample}     & \loadretiexample                                  \\
		\inlinebox{:LoadRETIExample num} & Load an example program by number \inlinebox{num} \\
		\inlinebox{:CompilePicoCBuffer}  & \compilepicocbuffer                               \\
		\inlinebox{:StartRETIBuffer}     & \startretibuffer
	\end{tblr}
	\caption{Commands}
	\label{tab:commands}
\end{table}

All keybindings from \ref{tab:global keybindings} besides the keybinding \inlinebox{Space, then r, then h} to hide the layout are also directly available by the start of neovim, if they were passed to the \inlinebox{setup} function as it can be seen in the configuration in \inlinebox{custom\_init.lua}.

Because the students who get assigned to test this plugin probably don't know anything about PicoC or the RETI assembler I prepared the keybinding \inlinebox{Space, then r, then l} and the command \inlinebox{:LoadRETIExample}. The keybinding just calls the command without arguments. The keybinding and the command without arguments open a menu of different interesting PicoC programs that get loaded into the buffer by submitting them via \inlinebox{Enter} and can then be compiled with either \inlinebox{Space, then r, then c} or \inlinebox{:CompilePicoCBuffer}. After compiling the compiled RETI code in the buffer can be debugged in the RETI-Debugger via \inlinebox{Space, then r, then s} or \inlinebox{:StartRETIBuffer}.

\begin{table}[H]
	\centering
	\begin{tblr}{
		width = \linewidth,
		colspec = {Q[1]Q[2]},
		row{1} = {PrimaryColor,fg=white},
		column{1} = {c},
		row{even} = {PrimaryColorDimmed},
		hlines = {PrimaryColor},
		vlines = {PrimaryColor},
		}
		Key                               & Effect                    \\
		\inlinebox{Space, then r, then l} & \loadretiexample          \\
		\inlinebox{Space, then r, then c} & \compilepicocbuffer       \\
		\inlinebox{Space, then r, then s} & \startretibuffer          \\
		\inlinebox{Space, then r, then h} & Hide RETI-Debugger layout
	\end{tblr}
	\caption{Global Keybindings}
	\label{tab:global keybindings}
\end{table}

The menus all share the same keybindings that can be looked up in table \ref{tab:menu keybindings}.

\begin{table}[H]
	\centering
	\begin{tblr}{
		width = \linewidth,
		colspec = {Q[1]Q[2]},
		row{1} = {PrimaryColor,fg=white},
		column{1} = {c},
		row{even} = {PrimaryColorDimmed},
		hlines = {PrimaryColor},
		vlines = {PrimaryColor},
		}
		Key                                                                                   & Effect                       \\
		\inlinebox{j}, \inlinebox{$\downarrow$}, \inlinebox{Tab}, \inlinebox{m}               & Focus next menu item         \\
		\inlinebox{k}, \inlinebox{$\uparrow$}, \inlinebox{Shift + Tab}, \inlinebox{Shift + m} & Focus previous menu item     \\
		\inlinebox{Esc}, \inlinebox{q}                                                        & Close menu                   \\
		\inlinebox{Enter}, \inlinebox{Space}                                                  & Submit the select menu entry
	\end{tblr}
	\caption{Menu Keybindings}
	\label{tab:menu keybindings}
\end{table}

The error and output popup windows that appear for syntactically incorrect RETI code and output from the instruction \inlinebox{CALL PRINT <reg>} also have special keybindings that can be looked up in table \ref{tab:popup keybindings}.

\begin{table}[H]
	\centering
	\begin{tblr}{
		width = \linewidth,
		colspec = {Q[2]Q[3]},
		row{1} = {PrimaryColor,fg=white},
		column{1} = {c},
		row{even} = {PrimaryColorDimmed},
		hlines = {PrimaryColor},
		vlines = {PrimaryColor},
		}
		Key                                                                                     & Effect      \\
		\inlinebox{Enter}, \inlinebox{Esc}, \inlinebox{q}, clicking outside of the popup buffer & Close popup
	\end{tblr}
	\caption{Popup Keybindings}
	\label{tab:popup keybindings}
\end{table}

The input window that appear for input requests from the instruction \inlinebox{CALL INPUT <reg>} also has special keybindings that can be looked up in table \ref{tab:input field keybindings}.

\begin{table}[H]
	\centering
	\begin{tblr}{
		width = \linewidth,
		colspec = {Q[1]Q[3]},
		row{1} = {PrimaryColor,fg=white},
		column{1} = {c},
		row{even} = {PrimaryColorDimmed},
		hlines = {PrimaryColor},
		vlines = {PrimaryColor},
		}
		Key               & Effect                                  \\
		\inlinebox{Enter} & Submit input typed into the input field
	\end{tblr}
	\caption{Input field keybindings}
	\label{tab:input field keybindings}
\end{table}

As soon as the window layout is mounted within the buffers of this layout the keybindings in table \ref{tab:buffer keybindings} can be used. The buffers of this window layout have their own keybindings and overwrite the vim default and all other keybindinds and only work within the buffers and not outside of the buffers.

\begin{table}[H]
	\centering
	\begin{tblr}{
		width = \linewidth,
		colspec = {Q[1]Q[4]},
		row{1} = {PrimaryColor,fg=white},
		column{1} = {c},
		row{even} = {PrimaryColorDimmed},
		hlines = {PrimaryColor},
		vlines = {PrimaryColor},
		}
		Key                   & Effect                                                                                                                                                                   \\
		\inlinebox{n}         & The next instruction will be executed in the RETI-Interpreter and the new state of the RETI processor is going to be displayed in the RETI-Debugger                      \\
		\inlinebox{Tab}       & Switch between windows in the layout                                                                                                                                     \\
		\inlinebox{Shift+Tab} & Switch backwards between windows in the layout                                                                                                                           \\
		\inlinebox{m}         & Opens menu to switch modes, the desired mode can be selected with \inlinebox{Enter}, there are only \alert{autoscrolling} and \alert{memory focus} mode available        \\
		\inlinebox{f}         & Focus memory if the \alert{memory focus} mode is active                                                                                                                  \\
		\inlinebox{r}         & Restart the RETI-Debugger with the currentely loaded RETI code                                                                                                           \\
		\inlinebox{q}         & Quit the RETI-Debugger, kill the RETI-Interpreter if it's running, unmount the window layout and delete all global keybindings that are not supposed to be always active \\
	\end{tblr}
	\caption{Buffer Keybindings}
	\label{tab:buffer keybindings}
\end{table}

% which-key erwähnen und backspace
% autompletion mit tab erwähnen
% LoadExample Argumente erwähnen

% \chapter{Bibliography}
% \printbibliography[heading=none]

\end{document}
